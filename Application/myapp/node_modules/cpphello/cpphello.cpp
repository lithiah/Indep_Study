#include <unistd.h>
#include <node.h>
#include <v8.h>
// #include "pugixml.hpp"
// #include "pugixml.cpp"
// #include "pugiconfig.hpp"
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include "math.h"
#include <pthread.h>

using namespace v8;

// ***************** LOAD AND READ DATA ***************** //
void loadVectors(std::map< int, std::vector<float> >* vectorsMap, Local<Array> data, int numberOfAttributes) {
    std::vector<float>* currentVector;
    int k = 0;
    currentVector = new std::vector<float>;

    for (uint32_t i=0; i < data->Length(); i++) {
        if (i > 0) {
            if (i % numberOfAttributes == 0) {
                (*vectorsMap)[k] = *currentVector;
                currentVector = new std::vector<float>;
                k += 1;
            }
        }
        currentVector->push_back(data->Get(i)->NumberValue());
    }
    //for last vector
    (*vectorsMap)[k] = *currentVector;
}

// ***************** CLUSTERING ***************** //
class Clusters {
public:
    //SETUP
    //constructor
    Clusters(std::map< int, std::vector<float> > Data, int NumberOfClusters, Local<v8::Array> activeDimensions);

    //initialize cluster centroids
    void setupClusters();

    //ALGORITHM
    void runSequential(int maxIterations);
    void runParallel(int maxIterations);

    //RESULTS
    Local<v8::Array> getClusterAssignments();

private:
    //VARIABLES
    //the raw vector data from XML
    std::map< int, std::vector<float> > data;
    //which dimensions to include in calculations
    Local<v8::Array> activeDimensions;
    //each point id mapped to it's cluster
    std::map<int, int> clusterAssignments;
    //vector of each cluster's size
    std::map<int, int> clusterSizes;
    //how many clusters to use
    int numberOfClusters;
    //vectors of each cluster centroid
    std::vector< std::vector<float> > centroids;

    //HELPER FUNCTIONS
    //calculate distance between a point and centroid
    float distance(std::vector<float> point, std::vector<float> centroid);
    //complete one sequential iteration of assignment
    void seqAssignmentStep();
    //complete one parallel iteration of assignment
    static void* parAssignmentStep1(void* arg);
    static void* parAssignmentStep2(void* arg);
    //calculate centroids after assignments
    void calculateCentroids();
};

Clusters::Clusters(std::map< int, std::vector<float> > Data, int NumberOfClusters, Local<v8::Array> ActiveDimensions) {
    data = Data;
    numberOfClusters = NumberOfClusters;
    activeDimensions = ActiveDimensions;
}

float Clusters::distance(std::vector<float> point, std::vector<float> centroid) {
    float distance = 0;
    for (int i = 0; i < (int) point.size(); i++) {
        if (activeDimensions->Get(i)->BooleanValue() == 1) {
            distance = distance + pow(point[i]-centroid[i], 2); //add squared difference from point to centroid
        }
    }
    return sqrt(distance);
}

void Clusters::setupClusters() {
    //assign inital clusters based on first n data points [!! WILL CHANGE THIS??]

    for (int i=0; i<numberOfClusters; i++) {
        centroids.push_back(data[i]);
    }
}

void Clusters::runSequential(int maxIterations) {
    for (int i=0; i<maxIterations; i++) {
        seqAssignmentStep();
        calculateCentroids();
    }
}

void Clusters::runParallel(int maxIterations) {
    pthread_t thread1, thread2;

    for (int i=0; i<maxIterations; i++) {
        pthread_create(&thread1, 0, parAssignmentStep1, this);
        pthread_create(&thread2, 0, parAssignmentStep2, this);
        pthread_join(thread1, 0);
        pthread_join(thread2, 0);

        calculateCentroids();
    }
}

void* Clusters::parAssignmentStep1(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int endPoint = int(x->data.size())/2;

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=0; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {
            newDistance = x->distance(x->data[i], x->centroids[j]);

            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void* Clusters::parAssignmentStep2(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = int((x->data.size()/2));

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i< (int) x->data.size(); i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = x->distance(x->data[i], x->centroids[j]);

            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void Clusters::seqAssignmentStep() {
    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=0; i< (int) data.size(); i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) centroids.size(); j++) {
            newDistance = distance(data[i], centroids[j]);

            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        clusterAssignments[i] = closestCluster;
    }//assigned cluster to each point
}

void Clusters::calculateCentroids() {
    //2: calculate new centroid for each cluster
    //for each point add dimension values to centroid

    //first clear centroids
    for (int i=0; i< (int) clusterSizes.size(); i++) {
        clusterSizes[i] = 0;
    }
    for (int i=0; i< (int) centroids.size(); i++) {
        for (int j=0; j< (int) centroids[0].size(); j++) {
            centroids[i][j] = 0;
        }
    }

    //add each point to corresponding centroid
    for (int i=0; i< (int) data.size(); i++) {
        clusterSizes[clusterAssignments[i]] = clusterSizes[clusterAssignments[i]] + 1;

        //for each dimension
        for (int j=0; j< (int) data[i].size(); j++){

            if (activeDimensions->Get(j)->BooleanValue() == 1) {
                centroids[clusterAssignments[i]][j] = centroids[clusterAssignments[i]][j] + data[i][j];
            }
        }
    }
    for (int i=0; i< (int) centroids.size(); i++) {
        for (int j=0; j< (int) centroids[0].size(); j++) {
            if (clusterSizes[i] > 0) {
                centroids[i][j] = centroids[i][j] / clusterSizes[i];
            }
            else {
                centroids[i][j] = 0;
            }
        }
    }
}

Local<v8::Array> Clusters::getClusterAssignments() {
    typedef std::map<int, int>::iterator it_type;

    Local<Array> jsResults = Array::New((int) clusterAssignments.size());

    for (it_type iterator = clusterAssignments.begin(); iterator != clusterAssignments.end(); iterator++) {
        jsResults->Set(Integer::New(iterator->first), Integer::New(iterator->second));
    }

    return jsResults;
}

Handle<Value> clustersInit(const Arguments& args) {
    HandleScope scope;

    //arguments needed: data, number of iterations, number of clusters, number of attributes, activeDimensions
    // get the param & convert to std

    Local<Array> data = Local<Array>::Cast(args[0]);

    int iterations = (int) (args[1]->Int32Value());
    int clustersCount = (int) args[2]->Int32Value();
    int numberOfAttributes = (int) args[3]->Int32Value();
    Local<Array> activeDimensions = Local<Array>::Cast(args[4]);

    // //where to put the data from xmlfile
    std::map< int, std::vector<float> > vectorsMap;

    loadVectors(&vectorsMap, data, numberOfAttributes);
    Clusters testCase = Clusters(vectorsMap, clustersCount, activeDimensions);
    testCase.setupClusters();
    testCase.runSequential(iterations);
    Local<Array> results = testCase.getClusterAssignments();

    return scope.Close(results);
}

///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

void init(Handle<Object> target) {
    NODE_SET_METHOD(target, "clustersInit", clustersInit);
}

NODE_MODULE(cpphello, init)
