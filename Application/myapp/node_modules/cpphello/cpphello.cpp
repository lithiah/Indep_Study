#include <unistd.h>
#include <node.h>
#include <v8.h>
// #include "pugixml.hpp"
// #include "pugixml.cpp"
// #include "pugiconfig.hpp"
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include "math.h"
#include <pthread.h>

using namespace v8;

// ***************** LOAD AND READ DATA ***************** //
void loadVectors(std::map< int, std::vector<float> >* vectorsMap, Local<Array> data, int numberOfAttributes) {
    std::vector<float>* currentVector;
    int k = 0;
    currentVector = new std::vector<float>;

    for (uint32_t i=0; i < data->Length(); i++) {
        if (i > 0) {
            if (i % numberOfAttributes == 0) {
                (*vectorsMap)[k] = *currentVector;
                currentVector = new std::vector<float>;
                k += 1;
            }
        }
        currentVector->push_back(data->Get(i)->NumberValue());
    }
    //for last vector
    (*vectorsMap)[k] = *currentVector;
}

// ***************** CLUSTERING ***************** //
class Clusters {
public:
    //SETUP
    //constructor
    Clusters(std::map< int, std::vector<float> > Data, int NumberOfClusters, std::vector<int> activeDimensions);

    //initialize cluster centroids
    void setupClusters();

    //ALGORITHM
    void runSequential(int maxIterations);
    void runParallel1(int maxIterations);
    void runParallel2(int maxIterations);
    void runParallel4(int maxIterations);
    void runParallel8(int maxIterations);

    //RESULTS
    Local<v8::Array> getClusterAssignments();

private:
    //VARIABLES
    //the raw vector data from XML
    std::map< int, std::vector<float> > data;
    //which dimensions to include in calculations
    std::vector<int> activeDimensions;
    //each point id mapped to it's cluster
    std::map<int, int> clusterAssignments;
    //vector of each cluster's size
    std::map<int, int> clusterSizes;
    //how many clusters to use
    int numberOfClusters;
    //vectors of each cluster centroid
    std::vector< std::vector<float> > centroids;

    //HELPER FUNCTIONS
    //calculate distance between a point and centroid
    float distance(std::vector<float> point, std::vector<float> centroid);
    //complete one sequential iteration of assignment
    void seqAssignmentStep();
    //complete one parallel iteration of assignment
    static void* par1Step1(void* arg);

    static void* par2Step1(void* arg);
    static void* par2Step2(void* arg);

    static void* par4Step1(void* arg);
    static void* par4Step2(void* arg);
    static void* par4Step3(void* arg);
    static void* par4Step4(void* arg);

    static void* par8Step1(void* arg);
    static void* par8Step2(void* arg);
    static void* par8Step3(void* arg);
    static void* par8Step4(void* arg);
    static void* par8Step5(void* arg);
    static void* par8Step6(void* arg);
    static void* par8Step7(void* arg);
    static void* par8Step8(void* arg);
    //calculate centroids after assignments
    void calculateCentroids();
};

Clusters::Clusters(std::map< int, std::vector<float> > Data, int NumberOfClusters, std::vector<int> ActiveDimensions) {
    data = Data;
    numberOfClusters = NumberOfClusters;
    activeDimensions = ActiveDimensions;
}

float Clusters::distance(std::vector<float> point, std::vector<float> centroid) {
    float distance = 0;
    for (int i = 0; i < (int) point.size(); i++) {
        if (activeDimensions[i]) {
            distance = distance + pow(point[i]-centroid[i], 2); //add squared difference from point to centroid
        }
    }
    return sqrt(distance);
}

void Clusters::setupClusters() {
    //assign inital clusters based on first n data points [!! WILL CHANGE THIS??]

    for (int i=0; i<numberOfClusters; i++) {
        centroids.push_back(data[i]);
    }

    for (int j=0; j< (int) data.size(); j++) {
        clusterAssignments[j] = -1;
    }
}

void Clusters::runSequential(int maxIterations) {
    for (int i=0; i<maxIterations; i++) {
        seqAssignmentStep();
        calculateCentroids();
    }
}

void Clusters::seqAssignmentStep() {
    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=0; i< (int) data.size(); i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) centroids.size(); j++) {
            newDistance = distance(data[i], centroids[j]);

            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        clusterAssignments[i] = closestCluster;
    }//assigned cluster to each point
}

void Clusters::runParallel1(int maxIterations) {
    pthread_t thread1;

    for (int i=0; i<maxIterations; i++) {
        pthread_create(&thread1, 0, par1Step1, this);
        pthread_join(thread1, 0);

        calculateCentroids();
    }
}

void* Clusters::par1Step1(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int endPoint = int(x->data.size());

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=0; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void Clusters::runParallel2(int maxIterations) {
    pthread_t thread1, thread2;

    for (int i=0; i<maxIterations; i++) {
        pthread_create(&thread1, 0, par2Step1, this);
        pthread_create(&thread2, 0, par2Step2, this);
        pthread_join(thread1, 0);
        pthread_join(thread2, 0);

        calculateCentroids();
    }
}

void* Clusters::par2Step1(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int endPoint = int(x->data.size())/2;

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=0; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void* Clusters::par2Step2(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = int((x->data.size()/2));

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i < (int) x->data.size(); i++) {
        closestCluster = 0;
        minDistance = 1000000000;

        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;
            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }
            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void Clusters::runParallel4(int maxIterations) {
    pthread_t thread1, thread2, thread3, thread4;

    for (int i=0; i<maxIterations; i++) {
        pthread_create(&thread1, 0, par4Step1, this);
        pthread_create(&thread2, 0, par4Step2, this);
        pthread_create(&thread3, 0, par4Step3, this);
        pthread_create(&thread4, 0, par4Step4, this);
        pthread_join(thread1, 0);
        pthread_join(thread2, 0);
        pthread_join(thread3, 0);
        pthread_join(thread4, 0);

        calculateCentroids();
    }
}

void* Clusters::par4Step1(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = 0;
    int endPoint = int(x->data.size())/4;

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void* Clusters::par4Step2(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = int(x->data.size())/4;
    int endPoint = int(x->data.size())/2;

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void* Clusters::par4Step3(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = int(x->data.size())/2;
    int endPoint = (int(x->data.size())/2) + (int(x->data.size())/4);

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void* Clusters::par4Step4(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = (int(x->data.size())/2) + (int(x->data.size())/4);
    int endPoint = int(x->data.size());

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void Clusters::runParallel8(int maxIterations) {
    pthread_t thread1, thread2, thread3, thread4, thread5, thread6, thread7, thread8;

    for (int i=0; i<maxIterations; i++) {
        pthread_create(&thread1, 0, par8Step1, this);
        pthread_create(&thread2, 0, par8Step2, this);
        pthread_create(&thread3, 0, par8Step3, this);
        pthread_create(&thread4, 0, par8Step4, this);
        pthread_create(&thread5, 0, par8Step5, this);
        pthread_create(&thread6, 0, par8Step6, this);
        pthread_create(&thread7, 0, par8Step7, this);
        pthread_create(&thread8, 0, par8Step8, this);
        pthread_join(thread1, 0);
        pthread_join(thread2, 0);
        pthread_join(thread3, 0);
        pthread_join(thread4, 0);
        pthread_join(thread5, 0);
        pthread_join(thread6, 0);
        pthread_join(thread7, 0);
        pthread_join(thread8, 0);
        
        calculateCentroids();
    }
}

void* Clusters::par8Step1(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = 0;
    int endPoint = 1*int(x->data.size())/8;

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void* Clusters::par8Step2(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = 1*int(x->data.size())/8;
    int endPoint = 2*(int(x->data.size())/8);

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void* Clusters::par8Step3(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = 2*int(x->data.size())/8;
    int endPoint = 3*(int(x->data.size())/8);

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void* Clusters::par8Step4(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = 3*int(x->data.size())/8;
    int endPoint = 4*(int(x->data.size())/8);

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void* Clusters::par8Step5(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = 4*int(x->data.size())/8;
    int endPoint = 5*(int(x->data.size())/8);

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void* Clusters::par8Step6(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = 5*int(x->data.size())/8;
    int endPoint = 6*(int(x->data.size())/8);

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void* Clusters::par8Step7(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = 6*int(x->data.size())/8;
    int endPoint = 7*(int(x->data.size())/8);

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void* Clusters::par8Step8(void* arg) {
    Clusters* x = static_cast<Clusters*>(arg); //reference to current class object

    int startPoint = 7*int(x->data.size())/8;
    int endPoint = int(x->data.size());

    //1: for each point calculate distance from centroid, determine which distance is smallest, assign to cluster with smaller distance
    int closestCluster;
    float minDistance;
    float newDistance;
    //for each point
    for (int i=startPoint; i<endPoint; i++) {
        closestCluster = 0;
        minDistance = 1000000000;
        //for each cluster
        for (int j=0; j< (int) x->centroids.size(); j++) {

            newDistance = 0;

            for (int k = 0; k < (int) x->activeDimensions.size(); k++) {
                if ((x->activeDimensions)[k]) {
                    newDistance = newDistance + pow(x->data[i][k] - x->centroids[j][k], 2); //add squared difference from point to centroid
                }
            }

            newDistance = sqrt(newDistance);


            if (newDistance < minDistance) {
                closestCluster = j;
                minDistance = newDistance;
            }
        }

        x->clusterAssignments[i] = closestCluster;

    }//assigned cluster to each point

    return 0;
}

void Clusters::calculateCentroids() {
    //2: calculate new centroid for each cluster
    //for each point add dimension values to centroid

    //first clear centroids
    for (int i=0; i< (int) clusterSizes.size(); i++) {
        clusterSizes[i] = 0;
    }
    for (int i=0; i< (int) centroids.size(); i++) {
        for (int j=0; j< (int) centroids[0].size(); j++) {
            centroids[i][j] = 0;
        }
    }

    //add each point to corresponding centroid
    for (int i=0; i< (int) data.size(); i++) {
        clusterSizes[clusterAssignments[i]] = clusterSizes[clusterAssignments[i]] + 1;

        //for each dimension
        for (int j=0; j< (int) data[i].size(); j++){

            if (activeDimensions[j] == 1) {
                centroids[clusterAssignments[i]][j] = centroids[clusterAssignments[i]][j] + data[i][j];
            }
        }
    }
    for (int i=0; i< (int) centroids.size(); i++) {
        for (int j=0; j< (int) centroids[0].size(); j++) {
            if (clusterSizes[i] > 0) {
                centroids[i][j] = centroids[i][j] / clusterSizes[i];
            }
            else {
                centroids[i][j] = 0;
            }
        }
    }
}

Local<v8::Array> Clusters::getClusterAssignments() {
    typedef std::map<int, int>::iterator it_type;

    Local<Array> jsResults = Array::New((int) clusterAssignments.size());

    for (it_type iterator = clusterAssignments.begin(); iterator != clusterAssignments.end(); iterator++) {
        if (Integer::New(iterator->second)->IsUndefined() || Integer::New(iterator->second)->IsNull()) {
            jsResults->Set(Integer::New(iterator->first), Integer::New(-1));
        }
        else {
            jsResults->Set(Integer::New(iterator->first), Integer::New(iterator->second));
        }
    }

    return jsResults;
}

std::vector<int> convertLocalArray(Local<Array> ActiveDimensions) {
    std::vector<int> activeDimensions;
    for (int i = 0; i < (int) ActiveDimensions->Length(); i++) {
        activeDimensions.push_back((int) ActiveDimensions->Get(i)->Int32Value());
    }
    return activeDimensions;
}

Handle<Value> clustersInitSeq(const Arguments& args) {
    HandleScope scope;

    Local<Array> data = Local<Array>::Cast(args[0]);
    int iterations = (int) (args[1]->Int32Value());
    int clustersCount = (int) args[2]->Int32Value();
    int numberOfAttributes = (int) args[3]->Int32Value();
    Local<Array> ActiveDimensions = Local<Array>::Cast(args[4]);

    std::map< int, std::vector<float> > vectorsMap;

    std::vector<int> activeDimensions = convertLocalArray(ActiveDimensions);

    loadVectors(&vectorsMap, data, numberOfAttributes);
    Clusters testCase = Clusters(vectorsMap, clustersCount, activeDimensions);
    testCase.setupClusters();
    testCase.runSequential(iterations);
    Local<Array> results = testCase.getClusterAssignments();

    return scope.Close(results);
}

Handle<Value> clustersInitPar1(const Arguments& args) {
    HandleScope scope;

    Local<Array> data = Local<Array>::Cast(args[0]);
    int iterations = (int) (args[1]->Int32Value());
    int clustersCount = (int) args[2]->Int32Value();
    int numberOfAttributes = (int) args[3]->Int32Value();
    Local<Array> ActiveDimensions = Local<Array>::Cast(args[4]);

    std::map< int, std::vector<float> > vectorsMap;

    std::vector<int> activeDimensions = convertLocalArray(ActiveDimensions);

    loadVectors(&vectorsMap, data, numberOfAttributes);
    Clusters testCase = Clusters(vectorsMap, clustersCount, activeDimensions);
    testCase.setupClusters();
    testCase.runParallel1(iterations);
    Local<Array> results = testCase.getClusterAssignments();

    return scope.Close(results);
}

Handle<Value> clustersInitPar2(const Arguments& args) {
    HandleScope scope;

    Local<Array> data = Local<Array>::Cast(args[0]);
    int iterations = (int) (args[1]->Int32Value());
    int clustersCount = (int) args[2]->Int32Value();
    int numberOfAttributes = (int) args[3]->Int32Value();
    Local<Array> ActiveDimensions = Local<Array>::Cast(args[4]);

    std::map< int, std::vector<float> > vectorsMap;

    std::vector<int> activeDimensions = convertLocalArray(ActiveDimensions);

    loadVectors(&vectorsMap, data, numberOfAttributes);
    Clusters testCase = Clusters(vectorsMap, clustersCount, activeDimensions);
    testCase.setupClusters();
    testCase.runParallel2(iterations);
    Local<Array> results = testCase.getClusterAssignments();

    return scope.Close(results);
}

Handle<Value> clustersInitPar4(const Arguments& args) {
    HandleScope scope;

    Local<Array> data = Local<Array>::Cast(args[0]);
    int iterations = (int) (args[1]->Int32Value());
    int clustersCount = (int) args[2]->Int32Value();
    int numberOfAttributes = (int) args[3]->Int32Value();
    Local<Array> ActiveDimensions = Local<Array>::Cast(args[4]);

    std::map< int, std::vector<float> > vectorsMap;

    std::vector<int> activeDimensions = convertLocalArray(ActiveDimensions);

    loadVectors(&vectorsMap, data, numberOfAttributes);
    Clusters testCase = Clusters(vectorsMap, clustersCount, activeDimensions);
    testCase.setupClusters();
    testCase.runParallel4(iterations);
    Local<Array> results = testCase.getClusterAssignments();

    return scope.Close(results);
}

Handle<Value> clustersInitPar8(const Arguments& args) {
    HandleScope scope;

    Local<Array> data = Local<Array>::Cast(args[0]);
    int iterations = (int) (args[1]->Int32Value());
    int clustersCount = (int) args[2]->Int32Value();
    int numberOfAttributes = (int) args[3]->Int32Value();
    Local<Array> ActiveDimensions = Local<Array>::Cast(args[4]);

    std::map< int, std::vector<float> > vectorsMap;

    std::vector<int> activeDimensions = convertLocalArray(ActiveDimensions);

    loadVectors(&vectorsMap, data, numberOfAttributes);
    Clusters testCase = Clusters(vectorsMap, clustersCount, activeDimensions);
    testCase.setupClusters();
    testCase.runParallel8(iterations);
    Local<Array> results = testCase.getClusterAssignments();

    return scope.Close(results);
}

///////////////////////////////////////////////////////

void init(Handle<Object> target) {
    NODE_SET_METHOD(target, "clustersInitSeq", clustersInitSeq);
    NODE_SET_METHOD(target, "clustersInitPar1", clustersInitPar1);
    NODE_SET_METHOD(target, "clustersInitPar2", clustersInitPar2);
    NODE_SET_METHOD(target, "clustersInitPar4", clustersInitPar4);
    NODE_SET_METHOD(target, "clustersInitPar8", clustersInitPar8);
}

NODE_MODULE(cpphello, init)
